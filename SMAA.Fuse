--[[--
    SMAA.Fuse

    Subpixel Morphological Antialiasing for DaVinci Resolve

--]]--


FuRegisterClass('SMAA', CT_Tool, {
    REGS_Category = "Color",
    REGS_OpIconString = '',
    REGS_OpDescription = 'Subpixel Morphological Antialiasing for DaVinci Resolve',
    REG_OpNoMask = true,
    REG_NoBlendCtrls = true,
    REG_NoObjMatCtrls = true,
    REG_NoMotionBlurCtrls = true,
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls = true,
    REG_TimeVariant = true,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false,
})

SMAAEdgesParams = [[
    int srcDoD[2]; // Size of the input texture.
    float threshold; // Edge detection threshold.
]]

SMAAEdgesKernel = [[

    #ifndef SMAA_RT_METRICS // This is just for compilation-time syntax checking.
    #define SMAA_RT_METRICS to_float4(1.0 / 1280.0, 1.0 / 720.0, 1280.0, 720.0)
    #endif

    __DEVICE__ float4 fmaf4(float4 a, float4 b, float4 c)
    {
        return to_float4(_fmaf(a.x, b.x, c.x), _fmaf(a.y, b.y, c.y), _fmaf(a.z, b.z, c.z), _fmaf(a.w, b.w, c.w));
    }
    
    __DEVICE__ float step2f(float edge, float2 v)
    {
        return v.x > edge ? 1.0 : (v.y > edge ? 1.0 : 0.0);
    }

    #ifndef SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR
    #define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0
    #endif

    __DEVICE__ float2 maxf2(float2 a, float2 b) {
        return to_float2(_fmaxf(a.x, b.x), _fmaxf(a.y, b.y));
    }
    
    // Edge Detection (First Pass)
    __DEVICE__ float2 SMAALumaEdgeDetectionPS(float2 texcoord,
                                float4 offset[3],
                                __TEXTURE2D__ colorTex,
                                float inThreshold
                                ) {
        // Calculate the threshold:
        float2 threshold = to_float2_s(inThreshold);

        // Calculate lumas:
        float3 weights = to_float3(0.2126, 0.7152, 0.0722);
        float4 col = _tex2DVec4(colorTex, texcoord.x, texcoord.y);
        float L = dot(to_float3(col.x, col.y, col.z), weights);

        col = _tex2DVec4(colorTex, offset[0].x, offset[0].y);
        float Lleft = dot(to_float3(col.x, col.y, col.z), weights);
        col = _tex2DVec4(colorTex, offset[0].z, offset[0].w);
        float Ltop = dot(to_float3(col.x, col.y, col.z), weights);

        // We do the usual threshold:
        float4 delta;
        delta.x = _fabs(L - Lleft);
        delta.y = _fabs(L - Ltop);
        float2 edges = step(threshold, to_float2(delta.x, delta.y));

        // Then discard if there is no edge:
        // TODO: Check result of edges here
        if (dot(edges, to_float2(1.0, 1.0)) == 0.0)
            return edges;

        // Calculate right and bottom deltas:
        col = _tex2DVec4(colorTex, offset[1].x, offset[1].y);
        float Lright = dot(to_float3(col.x, col.y, col.z), weights);
        col = _tex2DVec4(colorTex, offset[1].z, offset[1].w);
        float Lbottom  = dot(to_float3(col.x, col.y, col.z), weights);
        delta.z = _fabs(L - Lright);
        delta.w = _fabs(L -  Lbottom);

        // Calculate the maximum delta in the direct neighborhood:
        float2 maxDelta = maxf2(to_float2(delta.x, delta.y), to_float2(delta.z, delta.w));

        // Calculate left-left and top-top deltas:
        col = _tex2DVec4(colorTex, offset[2].x, offset[2].y);
        float Lleftleft = dot(to_float3(col.x, col.y, col.z), weights);
        col = _tex2DVec4(colorTex, offset[2].z, offset[2].w);
        float Ltoptop = dot(to_float3(col.x, col.y, col.z), weights);
        delta.z = _fabs(Lleft - Lleftleft);
        delta.w = _fabs(Ltop - Ltoptop);

        // Calculate the final maximum delta:
        maxDelta = maxf2(to_float2(maxDelta.x, maxDelta.y), to_float2(delta.z, delta.w));
        float finalDelta = _fmaxf(maxDelta.x, maxDelta.y);

        // Local contrast adaptation:
        edges.x *= step2f(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * to_float2(delta.x, delta.y));
        edges.y *= step2f(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * to_float2(delta.x, delta.y));

        return edges;
    }

    __KERNEL__ void SMAAEdgesKernel(
        __CONSTANTREF__ SMAAEdgesParams *params,
        __TEXTURE2D__ src,
        __TEXTURE2D_WRITE__ dst
    )
    {
        DEFINE_KERNEL_ITERATORS_XY(x, y);
        if (x < params->srcDoD[0] && y < params->srcDoD[1])
        {
            float2 texcoord = to_float2(x,y) + to_float2_s(0.5f);
            float2 iResolution = to_float2(params->srcDoD[0], params->srcDoD[1]);
            float2 iTexelSize = to_float2(1.f / params->srcDoD[0], 1.f / params->srcDoD[1]);
            float2 uv = texcoord / iResolution;

            float4 offset[3];
            offset[0] = fmaf4(to_float4(iTexelSize.x, iTexelSize.y, iTexelSize.x, iTexelSize.y), to_float4(-1.0, 0.0, 0.0, -1.0), to_float4(uv.x, uv.y, uv.x, uv.y));
            offset[1] = fmaf4(to_float4(iTexelSize.x, iTexelSize.y, iTexelSize.x, iTexelSize.y), to_float4( 1.0, 0.0, 0.0,  1.0), to_float4(uv.x, uv.y, uv.x, uv.y));
            offset[2] = fmaf4(to_float4(iTexelSize.x, iTexelSize.y, iTexelSize.x, iTexelSize.y), to_float4(-2.0, 0.0, 0.0, -2.0), to_float4(uv.x, uv.y, uv.x, uv.y));

            float2 edges = SMAALumaEdgeDetectionPS(uv, offset, src, params->threshold);

            _tex2DVec4Write(dst, x, y, to_float4(edges.x, edges.y, 0.0, 0.0));
        }
    }
]]

SMAABlendKernel = [[

    #ifndef SMAA_RT_METRICS // This is just for compilation-time syntax checking.
    #define SMAA_RT_METRICS to_float4(1.0 / 1280.0, 1.0 / 720.0, 1280.0, 720.0)
    #endif

    #define SMAA_AREATEX_MAX_DISTANCE 16
    #define SMAA_AREATEX_MAX_DISTANCE_DIAG 20
    #define SMAA_AREATEX_PIXEL_SIZE (1.0 / to_float2(160.0, 560.0))
    #define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)
    #define SMAA_SEARCHTEX_SIZE to_float2(66.0, 33.0)
    #define SMAA_SEARCHTEX_PACKED_SIZE to_float2(64.0, 16.0)

    __DEVICE__ float2 sqrt2f(float2 v)
    {
        return to_float2(_sqrtf(v.x), _sqrtf(v.y));
    }
    
    __DEVICE__ float2 round2f(float2 v)
    {
        return to_float2(_round(v.x), _round(v.y));
    }
    
    __DEVICE__ float4 round4f(float4 v)
    {
        return to_float4(_round(v.x), _round(v.y), _round(v.z), _round(v.w));
    }

    __DEVICE__ float2 abs2f(float2 v)
    {
        return to_float2(_fabs(v.x), _fabs(v.y));
    }

    __DEVICE__ float2 fmaf2(float2 a, float2 b, float2 c)
    {
        return to_float2(_fmaf(a.x, b.x, c.x), _fmaf(a.y, b.y, c.y));
    }
        
    __DEVICE__ float3 fmaf3(float3 a, float3 b, float3 c)
    {
        return to_float3(_fmaf(a.x, b.x, c.x), _fmaf(a.y, b.y, c.y), _fmaf(a.z, b.z, c.z));
    }

    __DEVICE__ float4 fmaf4(float4 a, float4 b, float4 c)
    {
        return to_float4(_fmaf(a.x, b.x, c.x), _fmaf(a.y, b.y, c.y), _fmaf(a.z, b.z, c.z), _fmaf(a.w, b.w, c.w));
    }

    __DEVICE__ float2 SMAAMovc2(float2 cond, float2 variable, float2 value) {
        if (cond.x > 0.0) variable.x = value.x;
        if (cond.y > 0.0) variable.y = value.y;

        return variable;
    }

    __DEVICE__ float2 saturatef2(float2 v) {
        return to_float2(_saturatef(v.x), _saturatef(v.y));
    }
    
    __DEVICE__ float step2f(float edge, float2 v)
    {
        return v.x > edge ? 1.0 : (v.y > edge ? 1.0 : 0.0);
    }

    __DEVICE__ void SMAAMovc4(float4 cond, float4* variable, float4 value) {
        float2 variableXY = SMAAMovc2(to_float2(cond.x, cond.y), to_float2(variable->x, variable->y), to_float2(value.x, value.y));
        float2 variableZW = SMAAMovc2(to_float2(cond.z, cond.w), to_float2(variable->z, variable->w), to_float2(value.z, value.w));
        variable->x = variableXY.x;
        variable->y = variableXY.y;
        variable->z = variableZW.x;
        variable->w = variableZW.y;
    }

    /**
    * Allows to decode two binary values from a bilinear-filtered access.
    */
    __DEVICE__ float2 SMAADecodeDiagBilinearAccess2(float2 e) {
        // Bilinear access for fetching 'e' have a 0.25 offset, and we are
        // interested in the R and G edges:
        //
        // +---G---+-------+
        // |   x o R   x   |
        // +-------+-------+
        //
        // Then, if one of these edge is enabled:
        //   Red:   (0.75 * X + 0.25 * 1) => 0.25 or 1.0
        //   Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0
        //
        // This function will unpack the values (mad + mul + round):
        // wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1
        e.x = e.x * _fabs(5.0 * e.x - 5.0 * 0.75);
        return round2f(e);
    }

    __DEVICE__ float4 SMAADecodeDiagBilinearAccess4(float4 e) {
        e.x = e.x * _fabs(5.0 * e.x - 5.0 * 0.75);
        e.z = e.z * _fabs(5.0 * e.y - 5.0 * 0.75);
        return round4f(e);
    }

    /**
    * These functions allows to perform diagonal pattern searches.
    */
    __DEVICE__ float2 SMAASearchDiag1(__TEXTURE2D__ edgesTex, float2 texcoord, float2 dir, float2* e, float maxSearchStepsDiag, float4 rtMetrics) {
        float4 coord = to_float4(texcoord.x, texcoord.y, -1.0, 1.0);
        float3 t = to_float3(rtMetrics.x, rtMetrics.y, 1.0);
        while (coord.z < float(maxSearchStepsDiag - 1) &&
            coord.w > 0.9) {
            float3 newCoord = fmaf3(t, to_float3(dir.x, dir.y, 1.0), to_float3(coord.x, coord.y, coord.z));
            coord.x = newCoord.x;
            coord.y = newCoord.y;
            coord.z = newCoord.z;
            float4 edg = _tex2DVec4(edgesTex, coord.x, coord.y);
            *e = to_float2(edg.x, edg.y);
            coord.w = dot(*e, to_float2(0.5, 0.5));
        }
        return to_float2(coord.z, coord.w);
    }

    __DEVICE__ float2 SMAASearchDiag2(__TEXTURE2D__ edgesTex, float2 texcoord, float2 dir, float2* e, float maxSearchStepsDiag, float4 rtMetrics) {
        float4 coord = to_float4(texcoord.x, texcoord.y, -1.0, 1.0);
        coord.x += 0.25 * rtMetrics.x; // See @SearchDiag2Optimization
        float3 t = to_float3(rtMetrics.x, rtMetrics.y, 1.0);
        while (coord.z < float(maxSearchStepsDiag - 1) &&
            coord.w > 0.9) {
            float3 newCoord = fmaf3(t, to_float3(dir.x, dir.y, 1.0), to_float3(coord.x, coord.y, coord.z));
            coord.x = newCoord.x;
            coord.y = newCoord.y;
            coord.z = newCoord.z;

            // @SearchDiag2Optimization
            // Fetch both edges at once using bilinear filtering:
            float4 edg = _tex2DVec4(edgesTex, coord.x, coord.y);
            *e = to_float2(edg.x, edg.y);
            *e = SMAADecodeDiagBilinearAccess2(*e);

            coord.w = dot(*e, to_float2(0.5, 0.5));
        }
        return to_float2(coord.z, coord.w);
    }
    
    #ifndef SMAA_AREATEX_SELECT
    #define SMAA_AREATEX_SELECT(tex) to_float2(tex.x, tex.y)
    #endif
    
    /** 
    * Similar to SMAAArea, this calculates the area corresponding to a certain
    * diagonal distance and crossing edges 'e'.
    */
    __DEVICE__ float2 SMAAAreaDiag(__TEXTURE2D__ areaTex, float2 dist, float2 e, float offset) {
        float2 texcoord = fmaf2(to_float2(SMAA_AREATEX_MAX_DISTANCE_DIAG, SMAA_AREATEX_MAX_DISTANCE_DIAG), e, dist);

        // We do a scale and bias for mapping to texel space:
        texcoord = fmaf2(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);

        // Diagonal areas are on the second half of the texture:
        texcoord.x += 0.5;

        // Move to proper place, according to the subpixel offset:
        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

        // Do it!
        return SMAA_AREATEX_SELECT(_tex2DVec4(areaTex, texcoord.x, texcoord.y));
    }

    /**
    * This searches for diagonal patterns and returns the corresponding weights.
    */
    __DEVICE__ float2 SMAACalculateDiagWeights(__TEXTURE2D__ edgesTex, __TEXTURE2D__ areaTex, float2 texcoord, float2 e, float4 subsampleIndices, float maxSearchStepsDiag, float4 rtMetrics) {
        float2 weights = to_float2(0.0, 0.0);

        // Search for the line ends:
        float4 d;
        float2 end;
        float2 searchResult;
        if (e.x > 0.0) {
            searchResult = SMAASearchDiag1(edgesTex, texcoord, to_float2(-1.0,  1.0), &end, maxSearchStepsDiag, rtMetrics);
            d.x = searchResult.x;
            d.z = searchResult.y;
            d.x += float(end.y > 0.9);
        } else
            d.x = 0.0;
            d.z = 0.0;
        searchResult = SMAASearchDiag1(edgesTex, texcoord, to_float2(1.0, -1.0), &end, maxSearchStepsDiag, rtMetrics);
        d.y = searchResult.x;
        d.w = searchResult.y;

        if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3
            // Fetch the crossing edges:
            float4 coords = fmaf4(to_float4(-d.x + 0.25, d.x, d.y, -d.y - 0.25), to_float4(rtMetrics.x, rtMetrics.y, rtMetrics.x, rtMetrics.y), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));
            float4 c;
            
            float2 offset = to_float2(-1.f * rtMetrics.x, 0);
            float4 edgeSample = _tex2DVec4(edgesTex, coords.x + offset.x, coords.y + offset.y);
            c.x = edgeSample.x;
            c.y = edgeSample.y;

            offset = to_float2(1 * rtMetrics.x, 0);
            edgeSample = _tex2DVec4(edgesTex, coords.z + offset.x, coords.w + offset.y);
            c.z = edgeSample.x;
            c.w = edgeSample.y;
            float4 decodeResult = SMAADecodeDiagBilinearAccess4(to_float4(c.x, c.y, c.z, c.w));
            c.y = decodeResult.x;
            c.x = decodeResult.y;
            c.w = decodeResult.z;
            c.z = decodeResult.w;

            // Merge crossing edges at each side into a single value:
            float2 cc = fmaf2(to_float2(2.0, 2.0), to_float2(c.x, c.z), to_float2(c.y, c.w));

            // Remove the crossing edge if we didn't found the end of the line:
            cc = SMAAMovc2(step(to_float2_s(0.9), to_float2(d.z, d.w)), cc, to_float2(0.0, 0.0)); // ERROR

            // Fetch the areas for this line:
            weights += SMAAAreaDiag(areaTex, to_float2(d.x, d.y), cc, subsampleIndices.z);
        }

        // Search for the line ends:
        float2 diagResult = SMAASearchDiag2(edgesTex, texcoord, to_float2(-1.0, -1.0), &end, maxSearchStepsDiag, rtMetrics);
        d.x = diagResult.x;
        d.z = diagResult.y;
        float4 edgeSample = _tex2DVec4(edgesTex, texcoord.x + 1.f * rtMetrics.x, texcoord.y);
        if (edgeSample.x > 0.0) {
            diagResult = SMAASearchDiag2(edgesTex, texcoord, to_float2(1.0, 1.0), &end, maxSearchStepsDiag, rtMetrics);
            d.y = diagResult.x;
            d.w = diagResult.y;
            d.y += float(end.y > 0.9);
        } else {
            d.y = 0.0;
            d.w = 0.0;
        }

        if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3
            // Fetch the crossing edges:
            float4 coords = fmaf4(to_float4(-d.x, -d.x, d.y, d.y), to_float4(rtMetrics.x, rtMetrics.y, rtMetrics.x, rtMetrics.y), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));
            float4 c;
            float4 edgeSample = _tex2DVec4(edgesTex, coords.x - 1.f * rtMetrics.x, coords.y);
            c.x  = edgeSample.y;
            edgeSample = _tex2DVec4(edgesTex, coords.x, coords.y - 1.f * rtMetrics.y);
            c.y  = edgeSample.x;
            edgeSample = _tex2DVec4(edgesTex, coords.z + 1.f * rtMetrics.x, coords.w);
            c.z = edgeSample.y;
            c.w = edgeSample.x;
            float2 cc = fmaf2(to_float2(2.0, 2.0), to_float2(c.x, c.z), to_float2(c.y, c.w));

            // Remove the crossing edge if we didn't found the end of the line:
            cc = SMAAMovc2(step(to_float2_s(0.9), to_float2(d.z, d.w)), cc, to_float2(0.0, 0.0));

            // Fetch the areas for this line:
            weights += SMAAAreaDiag(areaTex, to_float2(d.x, d.y), cc, subsampleIndices.w);
        }

        return weights;
    }

    #ifndef SMAA_SEARCHTEX_SELECT
    #define SMAA_SEARCHTEX_SELECT(sample) sample.x
    #endif

    //-----------------------------------------------------------------------------
    // Horizontal/Vertical Search Functions

    /**
    * This allows to determine how much length should we add in the last step
    * of the searches. It takes the bilinearly interpolated edge (see 
    * @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and
    * crossing edges are active.
    */
    __DEVICE__ float SMAASearchLength(__TEXTURE2D__ searchTex, float2 e, float offset) {
        // The texture is flipped vertically, with left and right cases taking half
        // of the space horizontally:
        float2 scale = SMAA_SEARCHTEX_SIZE * to_float2(0.5, -1.0);
        float2 bias = SMAA_SEARCHTEX_SIZE * to_float2(offset, 1.0);

        // Scale and bias to access texel centers:
        scale += to_float2(-1.0,  1.0);
        bias  += to_float2( 0.5, -0.5);

        // Convert from pixel coordinates to texcoords:
        // (We use SMAA_SEARCHTEX_PACKED_SIZE because the texture is cropped)
        scale *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;
        bias *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;

        // Lookup the search texture:
        float2 searchCoord = fmaf2(scale, e, bias);
        return SMAA_SEARCHTEX_SELECT(_tex2DVec4(searchTex, searchCoord.x, searchCoord.y));
    }

    /**
    * Horizontal/vertical search functions for the 2nd pass.
    */
    __DEVICE__ float SMAASearchXLeft(__TEXTURE2D__ edgesTex, __TEXTURE2D__ searchTex, float2 texcoord, float end, float4 rtMetrics) {
        /**
        * @PSEUDO_GATHER4
        * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
        * sample between edge, thus fetching four edges in a row.
        * Sampling with different offsets in each direction allows to disambiguate
        * which edges are active from the four fetched ones.
        */
        float2 e = to_float2(0.0, 1.0);
        while (texcoord.x > end && 
            e.y > 0.8281 && // Is there some edge not activated?
            e.x == 0.0) { // Or is there a crossing edge that breaks the line?
            float4 edgeSample = _tex2DVec4(edgesTex, texcoord.x, texcoord.y);
            e.x = edgeSample.x;
            e.y = edgeSample.y;
            texcoord = fmaf2(to_float2(-2.0, 0.0), to_float2(rtMetrics.x, rtMetrics.y), texcoord);
        }

        float offset = _fmaf(-(255.0 / 127.0), SMAASearchLength(searchTex, e, 0.0), 3.25);
        return _fmaf(rtMetrics.x, offset, texcoord.x);
    }

    __DEVICE__ float SMAASearchXRight(__TEXTURE2D__ edgesTex, __TEXTURE2D__ searchTex, float2 texcoord, float end, float4 rtMetrics) {
        float2 e = to_float2(0.0, 1.0);
        while (texcoord.x < end && 
            e.y > 0.8281 && // Is there some edge not activated?
            e.x == 0.0) { // Or is there a crossing edge that breaks the line?
            float4 edgeSample = _tex2DVec4(edgesTex, texcoord.x, texcoord.y);
            e.x = edgeSample.x;
            e.y = edgeSample.y;
            texcoord = fmaf2(to_float2(2.0, 0.0), to_float2(rtMetrics.x, rtMetrics.y), texcoord);
        }
        float offset = _fmaf(-(255.0 / 127.0), SMAASearchLength(searchTex, e, 0.5), 3.25);
        return _fmaf(-rtMetrics.x, offset, texcoord.x);
    }

    __DEVICE__ float SMAASearchYUp(__TEXTURE2D__ edgesTex, __TEXTURE2D__ searchTex, float2 texcoord, float end, float4 rtMetrics) {
        float2 e = to_float2(1.0, 0.0);
        while (texcoord.y > end && 
            e.x > 0.8281 && // Is there some edge not activated?
            e.y == 0.0) { // Or is there a crossing edge that breaks the line?
            float4 edgeSample = _tex2DVec4(edgesTex, texcoord.x, texcoord.y);
            e.x = edgeSample.x;
            e.y = edgeSample.y;
            texcoord = fmaf2(to_float2(0.0, -2.0), to_float2(rtMetrics.x, rtMetrics.y), texcoord);
        }
        float offset = _fmaf(-(255.0 / 127.0), SMAASearchLength(searchTex, to_float2(e.y, e.x), 0.0), 3.25);
        return _fmaf(rtMetrics.y, offset, texcoord.y);
    }

    __DEVICE__ float SMAASearchYDown(__TEXTURE2D__ edgesTex, __TEXTURE2D__ searchTex, float2 texcoord, float end, float4 rtMetrics) {
        float2 e = to_float2(1.0, 0.0);
        while (texcoord.y < end && 
            e.x > 0.8281 && // Is there some edge not activated?
            e.y == 0.0) { // Or is there a crossing edge that breaks the line?
            float4 edgeSample = _tex2DVec4(edgesTex, texcoord.x, texcoord.y);
            e.x = edgeSample.x;
            e.y = edgeSample.y;
            texcoord = fmaf2(to_float2(0.0, 2.0), to_float2(rtMetrics.x, rtMetrics.y), texcoord);
        }
        float offset = _fmaf(-(255.0 / 127.0), SMAASearchLength(searchTex, to_float2(e.y, e.x), 0.5), 3.25);
        return _fmaf(-rtMetrics.y, offset, texcoord.y);
    }

    /** 
    * Ok, we have the distance and both crossing edges. So, what are the areas
    * at each side of current edge?
    */
    __DEVICE__ float2 SMAAArea(__TEXTURE2D__ areaTex, float2 dist, float e1, float e2, float offset) {
        // Rounding prevents precision errors of bilinear filtering:
        float2 texcoord = fmaf2(to_float2(SMAA_AREATEX_MAX_DISTANCE, SMAA_AREATEX_MAX_DISTANCE), round(4.0 * to_float2(e1, e2)), dist);
        
        // We do a scale and bias for mapping to texel space:
        texcoord = fmaf2(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);

        // Move to proper place, according to the subpixel offset:
        texcoord.y = _fmaf(SMAA_AREATEX_SUBTEX_SIZE, offset, texcoord.y);

        // Do it!
        return SMAA_AREATEX_SELECT(_tex2DVec4(areaTex, texcoord.x, texcoord.y));
    }

    //-----------------------------------------------------------------------------
    // Corner Detection Functions

    __DEVICE__ float2 SMAADetectHorizontalCornerPattern(__TEXTURE2D__ edgesTex, float2 weights, float4 texcoord, float2 d, float cornerRounding, float4 rtMetrics) {
        float SMAA_CORNER_ROUNDING_NORM = (float(cornerRounding) / 100.0);
        float2 leftRight = step(to_float2(d.x, d.y), to_float2(d.y, d.x));
        float2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;

        rounding /= leftRight.x + leftRight.y; // Reduce blending for pixels in the center of a line.

        float2 factor = to_float2(1.0, 1.0);
        float4 sample = _tex2DVec4(edgesTex, texcoord.x + 0, texcoord.y + 1 * rtMetrics.y);
        factor.x -= rounding.x * sample.x;
        sample = _tex2DVec4(edgesTex, texcoord.z + 1 * rtMetrics.x, texcoord.w + 1 * rtMetrics.y);
        factor.x -= rounding.y * sample.x;
        sample = _tex2DVec4(edgesTex, texcoord.x + 0, texcoord.y - 2 * rtMetrics.y);
        factor.y -= rounding.x * sample.x;
        sample = _tex2DVec4(edgesTex, texcoord.z + 1 * rtMetrics.x, texcoord.w - 2 * rtMetrics.y);
        factor.y -= rounding.y * sample.x;
        
        weights *= saturatef2(factor);
        return weights;
    }

    __DEVICE__ float2 SMAADetectVerticalCornerPattern(__TEXTURE2D__ edgesTex, float2 weights, float4 texcoord, float2 d, float cornerRounding, float4 rtMetrics) {
        float SMAA_CORNER_ROUNDING_NORM = (float(cornerRounding) / 100.0);
        float2 leftRight = step(to_float2(d.x, d.y), to_float2(d.y, d.x));
        float2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;

        rounding /= leftRight.x + leftRight.y;

        float2 factor = to_float2(1.0, 1.0);
        float4 sample = _tex2DVec4(edgesTex, texcoord.x + 1.f * rtMetrics.x, texcoord.y);
        factor.x -= rounding.x * sample.y;
        sample = _tex2DVec4(edgesTex, texcoord.z + 1.f * rtMetrics.x, texcoord.w + 1.f * rtMetrics.y);
        factor.x -= rounding.y * sample.y;
        sample = _tex2DVec4(edgesTex, texcoord.x - 2.f * rtMetrics.x, texcoord.y);
        factor.y -= rounding.x * sample.y;
        sample = _tex2DVec4(edgesTex, texcoord.z - 2.f * rtMetrics.x, texcoord.w + 1.f * rtMetrics.y);
        factor.y -= rounding.y * sample.y;

        weights *= saturatef2(factor);
        return weights;
    }


    __DEVICE__ float4 SMAABlendingWeightCalculationPS(float2 texcoord,
                                        float2 pixcoord,
                                        float4 offset[3],
                                        __TEXTURE2D__ edgesTex,
                                        __TEXTURE2D__ areaTex,
                                        __TEXTURE2D__ searchTex,
                                        float4 subsampleIndices, // Just pass zero for SMAA 1x, see @SUBSAMPLE_INDICES. 
                                        float cornerRounding,
                                        float maxSearchStepsDiag,
                                        float4 rtMetrics) { 
        float4 weights = to_float4(0.0, 0.0, 0.0, 0.0);

        float4 edges = _tex2DVec4(edgesTex, texcoord.x, texcoord.y);
        float2 e = to_float2(edges.x, edges.y);

        if (e.y > 0.0) { // Edge at north
            // Diagonals have both north and west edges, so searching for them in
            // one of the boundaries is enough.
            float2 diagWeights = SMAACalculateDiagWeights(edgesTex, areaTex, texcoord, e, subsampleIndices, maxSearchStepsDiag, rtMetrics);
            weights.x = diagWeights.x;
            weights.y = diagWeights.y;

            // We give priority to diagonals, so if we find a diagonal we skip 
            // horizontal/vertical processing.
            if (weights.x == -weights.y) { // weights.x + weights.y == 0.0

            float2 d;

            // Find the distance to the left:
            float3 coords;
            coords.x = SMAASearchXLeft(edgesTex, searchTex, to_float2(offset[0].x, offset[0].y), offset[2].x, rtMetrics);
            coords.y = offset[1].y; // offset[1].y = texcoord.y - 0.25 * rtMetrics.y (@CROSSING_OFFSET)
            d.x = coords.x;

            // Now fetch the left crossing edges, two at a time using bilinear
            // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
            // discern what value each edge has:
            float4 edgeSample = _tex2DVec4(edgesTex, coords.x, coords.y);
            float e1 = edgeSample.x;

            // Find the distance to the right:
            coords.z = SMAASearchXRight(edgesTex, searchTex, to_float2(offset[0].z, offset[0].w), offset[2].y, rtMetrics);
            d.y = coords.z;

            // We want the distances to be in pixel units (doing this here allow to
            // better interleave arithmetic and memory accesses):
            d = abs2f(round2f(fmaf2(to_float2_s(rtMetrics.z), d, to_float2_s(-pixcoord.x))));

            // SMAAArea below needs a sqrt, as the areas texture is compressed
            // quadratically:
            float2 sqrt_d = sqrt2f(d);

            // Fetch the right crossing edges:
            float2 off = to_float2(1.f * rtMetrics.x, 0);
            float4 edgeSampleRight = _tex2DVec4(edgesTex, coords.z + off.x, coords.y + off.y);
            float e2 = edgeSampleRight.x;

            // Ok, we know how this pattern looks like, now it is time for getting
            // the actual area:
            float2 area = SMAAArea(areaTex, sqrt_d, e1, e2, subsampleIndices.y);
            weights.x = area.x;
            weights.y = area.y;

            // Fix corners:
            coords.y = texcoord.y;
            float2 weightsXY = SMAADetectHorizontalCornerPattern(edgesTex, to_float2(weights.x, weights.y), to_float4(coords.x, coords.y, coords.z, coords.y), d, cornerRounding, rtMetrics);
            weights.x = weightsXY.x;
            weights.y = weightsXY.y;

            } else
                e.x = 0.0; // Skip vertical processing.
        }

        if (e.x > 0.0) { // Edge at west
            float2 d;

            // Find the distance to the top:
            float3 coords;
            coords.y = SMAASearchYUp(edgesTex, searchTex, to_float2(offset[1].x, offset[1].y), offset[2].z, rtMetrics);
            coords.x = offset[0].x; // offset[1].x = texcoord.x - 0.25 * rtMetrics.x;
            d.x = coords.y;

            // Fetch the top crossing edges:
            float4 edgeSample = _tex2DVec4(edgesTex, coords.x, coords.y);
            float e1 = edgeSample.y;

            // Find the distance to the bottom:
            coords.z = SMAASearchYDown(edgesTex, searchTex, to_float2(offset[1].z, offset[1].w), offset[2].w, rtMetrics);
            d.y = coords.z;

            // We want the distances to be in pixel units:
            d = abs2f(round2f(fmaf2(to_float2_s(rtMetrics.w), d, to_float2_s(-pixcoord.y))));

            // SMAAArea below needs a sqrt, as the areas texture is compressed 
            // quadratically:
            float2 sqrt_d = sqrt2f(d);

            // Fetch the bottom crossing edges:
            float2 off = to_float2(0, 1.f * rtMetrics.y);
            float4 edgeSampleBottom = _tex2DVec4(edgesTex, coords.x + off.x, coords.z + off.y);
            float e2 = edgeSampleBottom.y;

            // Get the area for this direction:
            float2 area = SMAAArea(areaTex, sqrt_d, e1, e2, subsampleIndices.x);
            weights.z = area.x;
            weights.w = area.y;

            // Fix corners:
            coords.x = texcoord.x;
            float2 weightsZW = SMAADetectVerticalCornerPattern(edgesTex, to_float2(weights.z, weights.w), to_float4(coords.x, coords.y, coords.x, coords.z), d, cornerRounding, rtMetrics);
            weights.z = weightsZW.x;
            weights.w = weightsZW.y;
        }

        return weights;
    }
    
    __KERNEL__ void SMAABlendKernel(
        __CONSTANTREF__ SMAABlendParams *params,
        __TEXTURE2D__ edges,
        __TEXTURE2D__ area,
        __TEXTURE2D__ search,
        __TEXTURE2D_WRITE__ dst
    )
    {
        DEFINE_KERNEL_ITERATORS_XY(x, y);
        if (x < params->srcDoD[0] && y < params->srcDoD[1])
        {
            float2 pixcoord = to_float2(x,y) + to_float2_s(0.5f);
            float2 iResolution = to_float2(params->srcDoD[0], params->srcDoD[1]);
            float2 iTexelSize = to_float2(1.f / params->srcDoD[0], 1.f / params->srcDoD[1]);
            float4 rtMetrics = to_float4(iTexelSize.x, iTexelSize.y, iResolution.x, iResolution.y);
            float2 texcoord = pixcoord / iResolution;
            float4 offset[3];

            // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
            offset[0] = fmaf4(to_float4(iTexelSize.x, iTexelSize.y, iTexelSize.x, iTexelSize.y), to_float4(-0.25, -0.125,  1.25, -0.125), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));
            offset[1] = fmaf4(to_float4(iTexelSize.x, iTexelSize.y, iTexelSize.x, iTexelSize.y), to_float4(-0.125, -0.25, -0.125,  1.25), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));

            // And these for the searches, they indicate the ends of the loops:
            offset[2] = fmaf4(to_float4(iTexelSize.x, iTexelSize.x, iTexelSize.y, iTexelSize.y),
                            to_float4(-2.0, 2.0, -2.0, 2.0) * float(params->maxSearchSteps),
                            to_float4(offset[0].x, offset[0].z, offset[1].y, offset[1].w));

            float4 blend = SMAABlendingWeightCalculationPS(texcoord, pixcoord, offset, edges, area, search, to_float4_s(0.0f), params->cornerRounding, params->maxSearchStepsDiag, rtMetrics);

            _tex2DVec4Write(dst, x, y, blend);
        }
    }
]]

SMAABlendParams = [[
    int srcDoD[2]; // Width, Height
    int maxSearchSteps;
    int maxSearchStepsDiag;
    float cornerRounding;
]]

SMAANeighborhoodKernel = [[
    __DEVICE__ float4 fmaf4(float4 a, float4 b, float4 c)
    {
        return to_float4(_fmaf(a.x, b.x, c.x), _fmaf(a.y, b.y, c.y), _fmaf(a.z, b.z, c.z), _fmaf(a.w, b.w, c.w));
    }

    __DEVICE__ float2 SMAAMovc2(float2 cond, float2 variable, float2 value) {
        if (cond.x > 0.0) variable.x = value.x;
        if (cond.y > 0.0) variable.y = value.y;

        return variable;
    }

    __DEVICE__ void SMAAMovc4(float4 cond, float4* variable, float4 value) {
        float2 variableXY = SMAAMovc2(to_float2(cond.x, cond.y), to_float2(variable->x, variable->y), to_float2(value.x, value.y));
        float2 variableZW = SMAAMovc2(to_float2(cond.z, cond.w), to_float2(variable->z, variable->w), to_float2(value.z, value.w));
        variable->x = variableXY.x;
        variable->y = variableXY.y;
        variable->z = variableZW.x;
        variable->w = variableZW.y;
    }

    // Neighborhood Blending Pixel Shader (Third Pass)
    __DEVICE__ float4 SMAANeighborhoodBlendingPS(float2 texcoord,
                                    float4 offset,
                                    __TEXTURE2D__ colorTex,
                                    __TEXTURE2D__ blendTex,
                                    float4 rtMetrics
                                    ) {
        // Fetch the blending weights for current pixel:
        float4 a;
        float4 sample = _tex2DVec4(blendTex, offset.x, offset.y);
        a.x = sample.w; // Right
        sample = _tex2DVec4(blendTex, offset.z, offset.w);
        a.y = sample.y; // Top
        sample = _tex2DVec4(blendTex, texcoord.x, texcoord.y);
        a.w = sample.x; // Bottom / Left
        a.z = sample.z; // Bottom / Left

        // Is there any blending weight with a value greater than 0.0?
        if (dot(a, to_float4(1.0, 1.0, 1.0, 1.0)) < 1e-5) {
            float4 color = _tex2DVec4(colorTex, texcoord.x, texcoord.y);

            return color;
        } else {
            bool h = max(a.x, a.z) > max(a.y, a.w); // max(horizontal) > max(vertical)

            // Calculate the blending offsets:
            float4 blendingOffset = to_float4(0.0, a.y, 0.0, a.w);
            float2 blendingWeight = to_float2(a.y, a.w);
            SMAAMovc4(to_float4(h, h, h, h), &blendingOffset, to_float4(a.x, 0.0, a.z, 0.0));
            blendingWeight = SMAAMovc2(to_float2(h, h), blendingWeight, to_float2(a.x, a.z));
            blendingWeight /= dot(blendingWeight, to_float2(1.0, 1.0));

            // Calculate the texture coordinates:
            float4 blendingCoord = fmaf4(blendingOffset, to_float4(rtMetrics.x, rtMetrics.y, -rtMetrics.x, -rtMetrics.y), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));

            // We exploit bilinear filtering to mix current pixel with the chosen
            // neighbor:
            float4 color = blendingWeight.x * _tex2DVec4(colorTex, blendingCoord.x, blendingCoord.y);
            color += blendingWeight.y * _tex2DVec4(colorTex, blendingCoord.z, blendingCoord.w);

            return color;
        }
    }
    
    __KERNEL__ void SMAANeighborhoodKernel(
        __CONSTANTREF__ SMAANeighborhoodParams *params,
        __TEXTURE2D__ src,
        __TEXTURE2D__ blend,
        __TEXTURE2D_WRITE__ dst
    )
    {
        DEFINE_KERNEL_ITERATORS_XY(x, y);
        if (x < params->srcDoD[0] && y < params->srcDoD[1])
        {
            float2 pixcoord = to_float2(x,y) + to_float2_s(0.5f);
            float2 iResolution = to_float2(params->srcDoD[0], params->srcDoD[1]);
            float2 iTexelSize = to_float2(1.f / params->srcDoD[0], 1.f / params->srcDoD[1]);
            float4 rtMetrics = to_float4(iTexelSize.x, iTexelSize.y, iResolution.x, iResolution.y);
            float2 texcoord = pixcoord / iResolution;
            float4 offset = fmaf4(to_float4(rtMetrics.x, rtMetrics.y, rtMetrics.x, rtMetrics.y), to_float4( 1.0, 0.0, 0.0,  1.0), to_float4(texcoord.x, texcoord.y, texcoord.x, texcoord.y));
            
            float4 final = SMAANeighborhoodBlendingPS(texcoord, offset, src, blend, rtMetrics);

            _tex2DVec4Write(dst, x, y, final);
        }
    }
]]

SMAANeighborhoodParams = [[
    int srcDoD[2]; // Width, Height
]]

function Create()
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
    InArea = self:AddInput("Area", "Area", {
        LINKID_DataType = "Image",
        LINK_Main = 2,
    })
    InSearch = self:AddInput("Search", "Search", {
        LINKID_DataType = "Image",
        LINK_Main = 3,
    })
    InThreshold = self:AddInput("Threshold", "Threshold", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.05,
        INPS_StatusText = "Threshold for color difference to detect edges.",
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 0.5,
    })
    InMaxSearchSteps = self:AddInput("Max Search Steps", "MaxSearchSteps", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 32,
        INPS_StatusText = "Maximum steps performed in the horizontal/vertical pattern searches.",
        INP_MinAllowed = 0,
        INP_MaxAllowed = 112,
    })
    InMaxSearchStepsDiag = self:AddInput("Max Search Steps Diagonal", "MaxSearchStepsDiag", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 16,
        INPS_StatusText = "Maximum steps performed in diagonal pattern searches.",
        INP_MinAllowed = 0,
        INP_MaxAllowed = 20
    })
    InCornerRounding = self:AddInput("Corner Rounding", "CornerRounding", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 25,
        INPS_StatusText = "How sharp corners will be rounded.",
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 100
    })

    InDebugLabel = self:AddInput("Debug", "DebugLabel", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        INP_External = false,
        INP_Passive = true,
        INPS_StatusText = "Show intermediate results for debugging purposes.",
        LBLC_DropDownButton = true,
        LBLC_NumInputs = 4,
    })
    InShowEdges = self:AddInput("Show Edges", "ShowEdges", {
        LINKID_DataType = "Number",
        INP_Integer = true,
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Show edge detection texture of first pass.",
    })
    InShowBlend = self:AddInput("Show Blend", "ShowBlend", {
        LINKID_DataType = "Number",
        INP_Integer = true,
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Show blend texture of second pass.",
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })


    

end

function PrecalcProcess(req)
    local src = InImage:GetValue(req)

    local dod = req:GetInputDoD(InImage)
    local datawnd = dod:Intersect(src.DataWindow)

    local out = Image({
        IMG_Like = src,               
        IMG_NoData = true,
        IMG_DataWindow = datawnd
    })

    OutImage:Set(req, out)
end

function Process(req)
    local src = InImage:GetValue(req)
    local dod = req:GetInputDoD(InImage)
    local datawnd = dod:Intersect(src.DataWindow)
    local edges = Image({
        IMG_Like = src, 
        IMG_Depth = src.Depth < 7 and 7 or src.Depth, 
        IMG_DataWindow = datawnd
    })
    local blend = Image({
        IMG_Like = src, 
        IMG_Depth = src.Depth < 7 and 7 or src.Depth, 
        IMG_DataWindow = datawnd
    })
    local dst = Image({
        IMG_Like = src, 
        IMG_Depth = src.Depth < 7 and 7 or src.Depth, 
        IMG_DataWindow = datawnd
    })

    local area = InArea:GetValue(req)
    local search = InSearch:GetValue(req)

    if not req:IsPreCalc() then
        local nodeEdges = DVIPComputeNode(req, "SMAAEdgesKernel", SMAAEdgesKernel, "SMAAEdgesParams", SMAAEdgesParams)

        local params = nodeEdges:GetParamBlock(SMAAEdgesParams)
        params.srcDoD[0] = src.DataWindow:Width()
        params.srcDoD[1] = src.DataWindow:Height()
        params.threshold = InThreshold:GetValue(req).Value

        nodeEdges:SetParamBlock(params)

        nodeEdges:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        
        nodeEdges:AddInput("src", src)
        nodeEdges:AddOutput("dst", edges)

        local okEdges = nodeEdges:RunSession(req)

        if not okEdges then
            print("SMAA Edge Detection failed!")
            dst = nil
            dump(nodeEdges:GetErrorLog())
            OutImage:Set(req, dst)
            return
        end

        if InShowEdges:GetValue(req).Value == 1 then
            OutImage:Set(req, edges)
            return
        end

        local nodeBlend = DVIPComputeNode(req, "SMAABlendKernel", SMAABlendKernel, "SMAABlendParams", SMAABlendParams)

        local params = nodeBlend:GetParamBlock(SMAABlendParams)
        params.srcDoD[0] = src.DataWindow:Width()
        params.srcDoD[1] = src.DataWindow:Height()
        params.maxSearchSteps = InMaxSearchSteps:GetValue(req).Value
        params.maxSearchStepsDiag = InMaxSearchStepsDiag:GetValue(req).Value
        params.cornerRounding = InCornerRounding:GetValue(req).Value

        nodeBlend:SetParamBlock(params)

        nodeBlend:AddSampler("EdgeSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        nodeBlend:AddSampler("AreaSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        nodeBlend:AddSampler("SearchSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        
        nodeBlend:AddInput("edges", edges)
        nodeBlend:AddInput("area", area)
        nodeBlend:AddInput("search", search)
        nodeBlend:AddOutput("dst", blend)

        local okBlend = nodeBlend:RunSession(req)

        if not okBlend then
            print("SMAA Blend failed!")
            dst = nil
            dump(nodeBlend:GetErrorLog())
            OutImage:Set(req, dst)
            return
        end

        if InShowBlend:GetValue(req).Value == 1 then
            OutImage:Set(req, blend)
            return
        end

        local nodeNeighborhood = DVIPComputeNode(req, "SMAANeighborhoodKernel", SMAANeighborhoodKernel, "SMAANeighborhoodParams", SMAANeighborhoodParams)

        local params = nodeNeighborhood:GetParamBlock(SMAANeighborhoodParams)
        params.srcDoD[0] = src.DataWindow:Width()
        params.srcDoD[1] = src.DataWindow:Height()

        nodeNeighborhood:SetParamBlock(params)

        nodeNeighborhood:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        nodeNeighborhood:AddSampler("BlendSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
        
        nodeNeighborhood:AddInput("src", src)
        nodeNeighborhood:AddInput("blend", blend)
        nodeNeighborhood:AddOutput("dst", dst)

        local okNeighborhood = nodeNeighborhood:RunSession(req)

        if not okNeighborhood then
            print("SMAA Final Blend failed!")
            dst = nil
            dump(nodeNeighborhood:GetErrorLog())
            OutImage:Set(req, dst)
            return
        end
    end

    OutImage:Set(req, dst)
end